#!/usr/bin/env bash
#
# dbx - Database backup and restore utility
# Uses Docker containers for pg_dump/mysqldump (no local install needed)
# Supports SSH tunnels for remote databases (AWS RDS, EC2, etc.)
#
VERSION="0.4.2"
#
# Usage:
#   dbx backup <host> <database>
#   dbx restore <host>/<database>/latest [--name <name>]
#   dbx restore <backup-file> [--name <name>]
#   dbx list [host] [database]
#   dbx clean [--keep N]
#   dbx config edit|show|init
#   dbx vault set|get|list|delete <host>
#   dbx tunnel <host> [--keep]
#   dbx query <host> [database]
#

set -euo pipefail

# ============================================================================
# Source library modules
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

source "$LIB_DIR/core.sh"
source "$LIB_DIR/tunnel.sh"
source "$LIB_DIR/postgres.sh"
source "$LIB_DIR/mysql.sh"

# ============================================================================
# Commands
# ============================================================================

cmd_backup() {
  local host=""
  local database=""
  local verbose=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -v|--verbose)
        verbose=true
        shift
        ;;
      -*)
        die "Unknown option: $1"
        ;;
      *)
        if [[ -z "$host" ]]; then
          host="$1"
        elif [[ -z "$database" ]]; then
          database="$1"
        fi
        shift
        ;;
    esac
  done

  [[ -z "$host" ]] && die "Usage: dbx backup [-v] <host> <database>"
  [[ -z "$database" ]] && die "Usage: dbx backup [-v] <host> <database>"

  require_config
  require_jq
  require_docker

  # Check encryption requirements
  local encrypt=false
  if is_encryption_enabled; then
    require_gpg
    encrypt=true
    log_info "Encryption enabled"
  fi

  local host_config
  host_config=$(get_host_config "$host")
  [[ -z "$host_config" ]] && die "Host '$host' not found in config"

  # Create SSH tunnel if configured
  if has_ssh_tunnel "$host"; then
    create_ssh_tunnel "$host"
  fi

  local db_type
  db_type=$(get_db_type "$host")

  # Create backup directory
  local backup_dir="$DATA_DIR/$host/$database"
  mkdir -p "$backup_dir"

  # Generate filename
  local ts
  ts=$(timestamp)
  local backup_file="$backup_dir/${database}_${ts}.sql.zst"
  local meta_file="$backup_dir/${database}_${ts}.meta.json"

  local start_time
  start_time=$(date +%s)

  case "$db_type" in
    postgres|postgresql)
      pg_backup "$host" "$database" "$backup_file" "$verbose"
      ;;
    mysql|mariadb)
      mysql_backup "$host" "$database" "$backup_file" "$verbose"
      ;;
    *)
      die "Unknown database type: $db_type"
      ;;
  esac

  # Encrypt if enabled
  if [[ "$encrypt" == "true" ]]; then
    log_info "Encrypting backup..."
    encrypt_stream < "$backup_file" > "${backup_file}.gpg"
    rm -f "$backup_file"
    backup_file="${backup_file}.gpg"
  fi

  local end_time duration file_size
  end_time=$(date +%s)
  duration=$((end_time - start_time))
  file_size=$(stat -f%z "$backup_file" 2>/dev/null || stat -c%s "$backup_file")

  # Write metadata
  local excluded_json
  excluded_json=$(get_excluded_tables "$host" "$database" | jq -R -s 'split("\n") | map(select(. != ""))')

  cat > "$meta_file" <<EOF
{
  "database": "$database",
  "host": "$host",
  "type": "$db_type",
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "filename": "$(basename "$backup_file")",
  "size_bytes": $file_size,
  "size_human": "$(human_size "$file_size")",
  "duration_seconds": $duration,
  "encrypted": $encrypt,
  "excluded_tables": $excluded_json
}
EOF

  echo ""
  log_success "Backup saved to: $backup_file"
  log_info "Size: $(human_size "$file_size") | Duration: ${duration}s"
  [[ "$encrypt" == "true" ]] && log_info "Encrypted: AES-256"
}

cmd_restore() {
  local source="${1:-}"
  local target_name=""

  shift || true

  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --name|-n)
        target_name="$2"
        shift 2
        ;;
      *)
        die "Unknown option: $1"
        ;;
    esac
  done

  require_config
  require_jq
  require_docker

  local backup_file=""
  local host=""
  local database=""

  # Fuzzy selection if no source provided or just a host
  if [[ -z "$source" ]] || { [[ -n "$source" ]] && [[ ! -f "$source" ]] && [[ "$source" != */* ]]; }; then
    if ! command -v fzf &>/dev/null; then
      die "Usage: db restore <host>/<database>/latest [--name <name>]\n       Install fzf for interactive selection"
    fi

    # Build search path
    local search_dir="$DATA_DIR"
    [[ -n "$source" ]] && search_dir="$DATA_DIR/$source"

    if [[ ! -d "$search_dir" ]]; then
      die "No backups found in: $search_dir"
    fi

    # Find all backup files (including encrypted)
    local backups
    backups=$(find "$search_dir" -type f \( -name "*.sql.zst" -o -name "*.sql.gz" -o -name "*.sql" -o -name "*.sql.zst.gpg" -o -name "*.sql.gz.gpg" \) 2>/dev/null | sort -r)

    if [[ -z "$backups" ]]; then
      die "No backup files found in: $search_dir"
    fi

    # Format for fzf: show relative path, size, date
    local formatted
    formatted=$(echo "$backups" | while read -r f; do
      local rel_path="${f#$DATA_DIR/}"
      local size=$(ls -lh "$f" 2>/dev/null | awk '{print $5}')
      local date=$(ls -l "$f" 2>/dev/null | awk '{print $6, $7, $8}')
      printf "%-60s %8s  %s\n" "$rel_path" "$size" "$date"
    done)

    # Run fzf
    local selected
    selected=$(echo "$formatted" | fzf \
      --header="Select backup to restore (ESC to cancel)" \
      --prompt="Restore> " \
      --height=80% \
      --layout=reverse \
      --preview="echo 'File: {1}'; echo ''; zstd -dcq '$DATA_DIR/{1}' 2>/dev/null | head -30 || gzip -dc '$DATA_DIR/{1}' 2>/dev/null | head -30 || head -30 '$DATA_DIR/{1}'" \
      --preview-window=right:50%:wrap \
      | awk '{print $1}')

    if [[ -z "$selected" ]]; then
      log_info "Selection cancelled"
      return 0
    fi

    backup_file="$DATA_DIR/$selected"
    # Extract host/database from path
    host=$(echo "$selected" | cut -d'/' -f1)
    database=$(echo "$selected" | cut -d'/' -f2)
  # Parse source - could be path like "production/myapp/latest" or actual file
  elif [[ -f "$source" ]]; then
    backup_file="$source"
    # Try to extract host/database from path
    if [[ "$source" == "$DATA_DIR"/* ]]; then
      local rel_path="${source#$DATA_DIR/}"
      host=$(echo "$rel_path" | cut -d'/' -f1)
      database=$(echo "$rel_path" | cut -d'/' -f2)
    fi
  elif [[ "$source" == */* ]]; then
    # Parse as host/database/selector
    host=$(echo "$source" | cut -d'/' -f1)
    database=$(echo "$source" | cut -d'/' -f2)
    local selector=$(echo "$source" | cut -d'/' -f3)
    selector="${selector:-latest}"

    local backup_dir="$DATA_DIR/$host/$database"
    [[ ! -d "$backup_dir" ]] && die "No backups found for $host/$database"

    if [[ "$selector" == "latest" ]]; then
      # Find latest backup (encrypted or not)
      backup_file=$(ls -t "$backup_dir"/*.sql.zst.gpg "$backup_dir"/*.sql.zst 2>/dev/null | head -1)
    else
      backup_file="$backup_dir/$selector"
    fi

    [[ -z "$backup_file" || ! -f "$backup_file" ]] && die "Backup not found: $backup_file"
  else
    die "Invalid source: $source"
  fi

  [[ ! -f "$backup_file" ]] && die "Backup file not found: $backup_file"

  # Determine target database name
  if [[ -z "$target_name" ]]; then
    local base_name="${database:-$(basename "$backup_file" .sql.zst.gpg)}"
    base_name="${base_name%.sql.zst}"  # Handle non-encrypted
    base_name="${base_name%%_[0-9]*}"  # Remove timestamp suffix
    local date_suffix
    date_suffix=$(date +"%Y%m%d")

    # Find next available version
    local version=1
    while true; do
      target_name="${base_name}_v${version}_${date_suffix}"
      # Check if database exists (try both postgres and mysql)
      if docker exec "$POSTGRES_CONTAINER" psql -U postgres -lqt 2>/dev/null | grep -qw "$target_name"; then
        ((version++))
      elif docker exec "$MYSQL_CONTAINER" mysql -u root -e "SHOW DATABASES" 2>/dev/null | grep -qw "$target_name"; then
        ((version++))
      else
        break
      fi
    done
  fi

  # Determine database type from metadata or config
  local db_type=""
  local meta_file="${backup_file%.sql.zst}.meta.json"
  if [[ -f "$meta_file" ]]; then
    db_type=$(jq -r '.type' "$meta_file")
  elif [[ -n "$host" ]]; then
    db_type=$(get_db_type "$host")
  else
    # Try to detect from file content
    if decompress "$backup_file" | head -c 100 | grep -q "PostgreSQL"; then
      db_type="postgres"
    else
      db_type="mysql"
    fi
  fi

  log_info "Restoring: $(basename "$backup_file")"
  log_info "Target database: $target_name"

  case "$db_type" in
    postgres|postgresql)
      pg_restore_backup "$backup_file" "$target_name" 4
      ;;
    mysql|mariadb)
      mysql_restore_backup "$backup_file" "$target_name"
      ;;
    *)
      die "Unknown database type: $db_type"
      ;;
  esac

  echo ""
  log_success "Database restored as: $target_name"
}

cmd_list() {
  local host="${1:-}"
  local database="${2:-}"

  require_jq

  if [[ -n "$host" && -n "$database" ]]; then
    # List backups for specific host/database
    local backup_dir="$DATA_DIR/$host/$database"
    if [[ ! -d "$backup_dir" ]]; then
      log_warn "No backups found for $host/$database"
      return
    fi

    echo -e "${BOLD}Backups for $host/$database:${NC}"
    echo ""
    printf "%-40s %10s %12s\n" "FILENAME" "SIZE" "DATE"
    printf "%-40s %10s %12s\n" "--------" "----" "----"

    for meta in "$backup_dir"/*.meta.json; do
      [[ ! -f "$meta" ]] && continue
      local filename size_human timestamp
      filename=$(jq -r '.filename' "$meta")
      size_human=$(jq -r '.size_human' "$meta")
      timestamp=$(jq -r '.timestamp' "$meta" | cut -d'T' -f1)
      printf "%-40s %10s %12s\n" "$filename" "$size_human" "$timestamp"
    done
  elif [[ -n "$host" ]]; then
    # List databases for host
    local host_dir="$DATA_DIR/$host"
    if [[ ! -d "$host_dir" ]]; then
      log_warn "No backups found for host: $host"
      return
    fi

    echo -e "${BOLD}Databases with backups on $host:${NC}"
    for db_dir in "$host_dir"/*/; do
      [[ -d "$db_dir" ]] && echo "  $(basename "$db_dir")"
    done
  else
    # List all hosts
    if [[ ! -d "$DATA_DIR" ]]; then
      log_warn "No backups found"
      return
    fi

    echo -e "${BOLD}Available backup hosts:${NC}"
    for host_dir in "$DATA_DIR"/*/; do
      if [[ -d "$host_dir" ]]; then
        local h=$(basename "$host_dir")
        local count=$(find "$host_dir" -name "*.sql.zst" 2>/dev/null | wc -l | tr -d ' ')
        echo "  $h ($count backups)"
      fi
    done
  fi
}

cmd_clean() {
  local keep=10

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --keep|-k)
        keep="$2"
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done

  log_step "Cleaning old backups (keeping $keep per database)"

  local total_removed=0
  local total_freed=0

  for host_dir in "$DATA_DIR"/*/; do
    [[ ! -d "$host_dir" ]] && continue
    for db_dir in "$host_dir"/*/; do
      [[ ! -d "$db_dir" ]] && continue

      local backups=()
      while IFS= read -r f; do
        [[ -n "$f" ]] && backups+=("$f")
      done < <(ls -t "$db_dir"/*.sql.zst.gpg "$db_dir"/*.sql.zst 2>/dev/null)

      if [[ ${#backups[@]} -gt $keep ]]; then
        local to_remove=("${backups[@]:$keep}")
        for backup in "${to_remove[@]}"; do
          local size meta_file
          size=$(stat -f%z "$backup" 2>/dev/null || stat -c%s "$backup")
          total_freed=$((total_freed + size))
          # Handle both encrypted and non-encrypted meta files
          meta_file="${backup%.gpg}"
          meta_file="${meta_file%.sql.zst}.meta.json"
          rm -f "$backup" "$meta_file"
          ((total_removed++))
          log_info "Removed: $(basename "$backup")"
        done
      fi
    done
  done

  if [[ $total_removed -gt 0 ]]; then
    log_success "Removed $total_removed backups, freed $(human_size $total_freed)"
  else
    log_info "No old backups to remove"
  fi
}

cmd_vault() {
  local action="${1:-}"
  local host="${2:-}"

  case "$action" in
    set)
      [[ -z "$host" ]] && die "Usage: dbx vault set <host>"

      require_config
      require_jq

      # Get host info from config
      local db_host db_port db_user db_type
      db_type=$(get_config_value ".hosts[\"$host\"].type")
      db_host=$(get_config_value ".hosts[\"$host\"].host")
      db_port=$(get_config_value ".hosts[\"$host\"].port")
      db_user=$(get_config_value ".hosts[\"$host\"].user")

      [[ -z "$db_type" ]] && die "Host '$host' not found in config. Run: dbx config edit"

      echo -e "${BOLD}Setting credentials for: $host${NC}"
      echo "  Type: $db_type"
      echo "  Host: $db_host:$db_port"
      echo "  User: $db_user"
      echo ""

      # Prompt for password
      echo -n "Password: "
      read -rs password
      echo ""

      if [[ -z "$password" ]]; then
        die "Password cannot be empty"
      fi

      # Store in keychain
      keychain_set "$host" "$password"
      log_success "Credentials stored in macOS Keychain for: $host"
      log_info "Password will be retrieved automatically during backup"
      ;;

    get)
      [[ -z "$host" ]] && die "Usage: dbx vault get <host>"
      local pass
      pass=$(keychain_get "$host" 2>/dev/null || true)
      if [[ -n "$pass" ]]; then
        echo "$pass"
      else
        die "No credentials found for: $host"
      fi
      ;;

    delete|rm)
      [[ -z "$host" ]] && die "Usage: dbx vault delete <host>"
      if keychain_delete "$host"; then
        log_success "Credentials removed for: $host"
      else
        log_warn "No credentials found for: $host"
      fi
      ;;

    list|ls)
      echo -e "${BOLD}Stored credentials:${NC}"
      local hosts
      hosts=$(keychain_list)
      if [[ -n "$hosts" ]]; then
        echo "$hosts" | while read -r h; do
          [[ "$h" == "_dbx_encryption_key" ]] && continue
          echo "  $h"
        done
      else
        echo "  (none)"
      fi
      # Check encryption key
      if get_encryption_key &>/dev/null; then
        echo ""
        echo -e "${BOLD}Encryption:${NC}"
        echo "  Key is set"
      fi
      ;;

    set-encryption-key)
      echo -e "${BOLD}Setting encryption key for backups${NC}"
      echo ""
      echo "This passphrase will be used to encrypt all backups."
      echo "Store it safely - you cannot recover backups without it!"
      echo ""

      echo -n "Encryption passphrase: "
      read -rs passphrase
      echo ""

      if [[ -z "$passphrase" ]]; then
        die "Passphrase cannot be empty"
      fi

      echo -n "Confirm passphrase: "
      read -rs passphrase_confirm
      echo ""

      if [[ "$passphrase" != "$passphrase_confirm" ]]; then
        die "Passphrases do not match"
      fi

      set_encryption_key "$passphrase"
      log_success "Encryption key stored"
      log_info "Enable encryption in config: dbx config edit"
      log_info "Set \"encryption\": true in defaults section"
      ;;

    delete-encryption-key)
      if delete_encryption_key; then
        log_success "Encryption key removed"
      else
        log_warn "No encryption key found"
      fi
      ;;

    *)
      die "Usage: dbx vault <set|get|delete|list|set-encryption-key|delete-encryption-key> [host]"
      ;;
  esac
}

cmd_config() {
  local action="${1:-show}"

  case "$action" in
    init)
      mkdir -p "$CONFIG_DIR"
      if [[ -f "$CONFIG_FILE" ]]; then
        log_warn "Config already exists: $CONFIG_FILE"
        return
      fi

      cat > "$CONFIG_FILE" <<'EOF'
{
  "hosts": {
    "example-mysql": {
      "type": "mysql",
      "user": "backup_user",
      "definer_handling": "strip",
      "ssh_tunnel": {
        "jump_host": "bastion-server",
        "target_host": "mysql.internal",
        "target_port": 3306
      },
      "databases": {
        "myapp": {
          "exclude_data": ["sessions", "cache", "jobs"]
        }
      }
    },
    "example-rds": {
      "type": "mysql",
      "user": "admin",
      "definer_handling": "strip",
      "ssh_tunnel": {
        "jump_host": "bastion",
        "target_host": "mydb.xxxx.us-east-1.rds.amazonaws.com",
        "target_port": 3306
      },
      "databases": {
        "production": {
          "exclude_data": ["audit_logs", "sessions"]
        }
      }
    },
    "local": {
      "type": "postgres",
      "host": "localhost",
      "port": 5432,
      "user": "postgres",
      "databases": {
        "devdb": {}
      }
    }
  },
  "defaults": {
    "compression": "zstd",
    "compression_level": 3,
    "parallel_jobs": 4,
    "keep_backups": 10,
    "definer_handling": "strip",
    "encryption": false
  }
}
EOF
      log_success "Config created: $CONFIG_FILE"
      log_info "Edit it with: dbx config edit"
      log_info "Store passwords with: dbx vault set <host>"
      ;;

    edit)
      require_config
      "${EDITOR:-vim}" "$CONFIG_FILE"
      ;;

    show)
      require_config
      require_jq
      jq '.' "$CONFIG_FILE"
      ;;

    *)
      die "Unknown config action: $action (use: init, edit, show)"
      ;;
  esac
}

cmd_analyze() {
  local host="${1:-}"
  local database="${2:-}"

  [[ -z "$host" ]] && die "Usage: db analyze <host> <database>"
  [[ -z "$database" ]] && die "Usage: db analyze <host> <database>"

  require_config
  require_jq
  require_docker

  local host_config
  host_config=$(get_host_config "$host")
  [[ -z "$host_config" ]] && die "Host '$host' not found in config"

  # Create SSH tunnel if configured
  if has_ssh_tunnel "$host"; then
    create_ssh_tunnel "$host"
  fi

  local db_type
  db_type=$(get_db_type "$host")

  case "$db_type" in
    mysql|mariadb)
      analyze_mysql "$host" "$database"
      ;;
    postgres|postgresql)
      analyze_postgres "$host" "$database"
      ;;
    *)
      die "Unknown database type: $db_type"
      ;;
  esac
}

cmd_query() {
  local host="${1:-}"
  local database="${2:-}"

  [[ -z "$host" ]] && die "Usage: db query <host> [database]"

  require_config
  require_jq
  require_docker

  local host_config
  host_config=$(get_host_config "$host")
  [[ -z "$host_config" ]] && die "Host '$host' not found in config"

  # Create SSH tunnel if configured
  if has_ssh_tunnel "$host"; then
    create_ssh_tunnel "$host"
  fi

  local db_type db_host db_port db_user db_pass
  db_type=$(get_db_type "$host")
  db_host=$(get_effective_host "$host")
  db_port=$(get_effective_port "$host")
  db_user=$(get_config_value ".hosts[\"$host\"].user")
  db_pass=$(get_password "$host")

  log_step "Connecting to $host ($db_type)"
  log_info "Host: $db_host:$db_port, User: $db_user"
  [[ -n "$database" ]] && log_info "Database: $database"

  case "$db_type" in
    postgres|postgresql)
      require_container "$POSTGRES_CONTAINER"
      if [[ -n "$database" ]]; then
        docker exec -it -e PGPASSWORD="$db_pass" "$POSTGRES_CONTAINER" \
          psql -h "$db_host" -p "$db_port" -U "$db_user" -d "$database"
      else
        docker exec -it -e PGPASSWORD="$db_pass" "$POSTGRES_CONTAINER" \
          psql -h "$db_host" -p "$db_port" -U "$db_user"
      fi
      ;;
    mysql|mariadb)
      require_container "$MYSQL_CONTAINER"
      if [[ -n "$database" ]]; then
        docker exec -it -e MYSQL_PWD="$db_pass" "$MYSQL_CONTAINER" \
          mysql -h "$db_host" -P "$db_port" -u "$db_user" "$database"
      else
        docker exec -it -e MYSQL_PWD="$db_pass" "$MYSQL_CONTAINER" \
          mysql -h "$db_host" -P "$db_port" -u "$db_user"
      fi
      ;;
    *)
      die "Unknown database type: $db_type"
      ;;
  esac
}

# ============================================================================
# TUI Mode (requires gum)
# ============================================================================

require_gum() {
  command -v gum &>/dev/null || die "gum is required for TUI mode. Install: brew install gum (or go install github.com/charmbracelet/gum@latest)"
}

# Check for updates (cached for session)
LATEST_VERSION=""
check_for_updates() {
  if [[ -z "$LATEST_VERSION" ]]; then
    LATEST_VERSION=$(curl -fsSL --connect-timeout 2 "https://raw.githubusercontent.com/steig/dbx/main/dbx" 2>/dev/null | grep '^VERSION=' | cut -d'"' -f2 || echo "")
  fi
  if [[ -n "$LATEST_VERSION" && "$LATEST_VERSION" != "$VERSION" ]]; then
    return 0  # Update available
  fi
  return 1  # No update
}

run_self_update() {
  echo ""
  gum style --foreground 39 --bold "  Updating dbx..."
  echo ""
  if curl -fsSL https://raw.githubusercontent.com/steig/dbx/main/install.sh | bash; then
    echo ""
    gum style --foreground 40 --bold "  ‚úì Updated! Please restart dbx tui"
    sleep 2
    exit 0
  else
    gum style --foreground 196 --bold "  ‚úó Update failed"
    sleep 2
  fi
}

list_hosts() {
  require_config
  require_jq
  jq -r '.hosts | keys[]' "$CONFIG_FILE"
}

list_databases_for_host() {
  local host="$1"
  require_jq
  jq -r ".hosts[\"$host\"].databases | keys[]" "$CONFIG_FILE" 2>/dev/null
}

# Get backup stats for a host/database
get_backup_stats() {
  local host="$1"
  local db="$2"
  local dir="$DATA_DIR/$host/$db"
  if [[ -d "$dir" ]]; then
    local count size latest
    count=$(find "$dir" -name "*.sql.zst*" 2>/dev/null | wc -l | tr -d ' ')
    size=$(du -sh "$dir" 2>/dev/null | cut -f1)
    latest=$(ls -t "$dir"/*.sql.zst* 2>/dev/null | head -1 | xargs basename 2>/dev/null | sed 's/.*_\([0-9]*\)_.*/\1/' | head -c8)
    echo "${count:-0}|${size:-0B}|${latest:-never}"
  else
    echo "0|0B|never"
  fi
}

tui_header() {
  clear
  gum style \
    --border double \
    --border-foreground 99 \
    --padding "0 2" \
    --margin "0 0 1 0" \
    --bold \
    --foreground 99 \
    "  dbx $VERSION  Database Backup & Restore"
}

tui_dashboard() {
  tui_header

  # Hosts section
  local hosts
  hosts=$(list_hosts 2>/dev/null || true)

  if [[ -z "$hosts" ]]; then
    echo "No hosts configured. Run: dbx config edit" | gum style \
      --border rounded --border-foreground 39 --padding "1 2" --width 60
  else
    {
      printf "%-18s %-10s %-10s %s\n" "HOST" "TYPE" "DATABASES" "BACKUPS"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      while IFS= read -r host; do
        local htype dbs_count backup_count
        htype=$(get_db_type "$host" 2>/dev/null || echo "?")
        dbs_count=$(list_databases_for_host "$host" 2>/dev/null | wc -l | tr -d ' ')
        backup_count=$(find "$DATA_DIR/$host" -name "*.sql.zst*" 2>/dev/null | wc -l | tr -d ' ')
        printf "%-18s %-10s %-10s %s\n" "$host" "$htype" "${dbs_count:-0} dbs" "${backup_count:-0} files"
      done <<< "$hosts"
    } | gum style --border rounded --border-foreground 39 --padding "1 2" --width 60
  fi

  echo ""

  # Recent backups section
  if [[ -d "$DATA_DIR" ]]; then
    local backup_files
    backup_files=$(find "$DATA_DIR" -name "*.sql.zst*" -type f 2>/dev/null | head -5)
    if [[ -n "$backup_files" ]]; then
      {
        printf "%-38s %8s\n" "RECENT BACKUPS" "SIZE"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        while IFS= read -r f; do
          [[ -z "$f" ]] && continue
          local rel size lock=""
          rel="${f#$DATA_DIR/}"
          size=$(ls -lh "$f" 2>/dev/null | awk '{print $5}')
          [[ "$f" == *.gpg ]] && lock=" üîí"
          printf "%-38s %8s%s\n" "${rel:0:38}" "$size" "$lock"
        done <<< "$backup_files"
      } | gum style --border rounded --border-foreground 220 --padding "1 2" --width 60
    else
      echo "No backups yet" | gum style --border rounded --border-foreground 220 --padding "1 2" --width 60
    fi
  else
    echo "No backups yet" | gum style --border rounded --border-foreground 220 --padding "1 2" --width 60
  fi

  echo ""

  # Storage info
  local storage_info="Backups: $DATA_DIR"
  if [[ -d "$DATA_DIR" ]]; then
    local total_size total_count
    total_size=$(du -sh "$DATA_DIR" 2>/dev/null | cut -f1 || echo "0B")
    total_count=$(find "$DATA_DIR" -name "*.sql.zst*" 2>/dev/null | wc -l | tr -d ' ')
    storage_info="Total: ${total_count:-0} backups (${total_size})"
  fi
  if is_encryption_enabled 2>/dev/null; then
    storage_info+="  üîí Encrypted"
  fi
  gum style --faint "  $storage_info"

  # Check for updates
  if check_for_updates; then
    echo ""
    echo "‚ö° Update: $VERSION ‚Üí $LATEST_VERSION (select Update)" | gum style \
      --border rounded --border-foreground 208 --foreground 208 --bold --padding "0 2" --width 60
  fi
  echo ""
}

tui_action_menu() {
  local options=(
    "‚¨Ü  Backup database"
    "‚¨á  Restore backup"
    "‚å®  Query database"
    "üìä Analyze tables"
    "üìã List all backups"
    "üßπ Clean old backups"
    "üîë Vault & credentials"
    "‚öô  Configuration"
  )

  # Add update option if available
  if check_for_updates; then
    options+=("‚ö° Update to $LATEST_VERSION")
  fi

  options+=("‚ùå Quit")

  printf '%s\n' "${options[@]}" | gum choose --height 12 --cursor "‚ñ∏ " --cursor-prefix "" --selected-prefix "‚ñ∏ " --unselected-prefix "  "
}

tui_select_host() {
  local hosts
  hosts=$(list_hosts)
  if [[ -z "$hosts" ]]; then
    gum style --foreground 196 --bold "  No hosts configured!"
    sleep 1
    return 1
  fi

  local host_options=""
  while IFS= read -r host; do
    local htype
    htype=$(get_db_type "$host" 2>/dev/null)
    host_options+="$host ($htype)"$'\n'
  done <<< "$hosts"

  local selected
  selected=$(echo "$host_options" | gum choose --header "Select host:")
  echo "$selected" | sed 's/ (.*//'
}

tui_select_backup() {
  if [[ ! -d "$DATA_DIR" ]]; then
    gum style --foreground 196 "No backups found"
    return 1
  fi

  local backups
  backups=$(find "$DATA_DIR" -type f \( -name "*.sql.zst" -o -name "*.sql.zst.gpg" \) 2>/dev/null | xargs ls -t 2>/dev/null)
  if [[ -z "$backups" ]]; then
    gum style --foreground 196 "No backup files found"
    return 1
  fi

  local formatted=""
  while IFS= read -r f; do
    [[ -z "$f" ]] && continue
    local rel size date lock=""
    rel="${f#$DATA_DIR/}"
    size=$(ls -lh "$f" 2>/dev/null | awk '{print $5}')
    date=$(ls -l "$f" 2>/dev/null | awk '{print $6, $7}')
    [[ "$f" == *.gpg ]] && lock="üîí "
    formatted+="${lock}${rel} (${size}, ${date})"$'\n'
  done <<< "$backups"

  local selected
  selected=$(echo "$formatted" | gum filter --height 15 --header "Select backup (type to filter):")
  [[ -z "$selected" ]] && return 1

  # Extract path (remove lock emoji, size, date)
  echo "$selected" | sed 's/^üîí //' | sed 's/ ([^)]*,[^)]*)$//'
}

cmd_tui() {
  require_gum
  require_config
  require_jq

  while true; do
    tui_dashboard

    local action
    action=$(tui_action_menu)

    case "$action" in
      "‚¨Ü  Backup database")
        echo ""
        local host
        host=$(tui_select_host) || continue
        [[ -z "$host" ]] && continue

        local databases db
        databases=$(list_databases_for_host "$host")
        if [[ -n "$databases" ]]; then
          db=$(echo "$databases" | gum choose --header "Select database:")
        fi
        if [[ -z "$db" ]]; then
          db=$(gum input --placeholder "Enter database name" --header "Database:")
        fi
        [[ -z "$db" ]] && continue

        echo ""
        gum spin --spinner dot --title "Backing up $host/$db..." -- dbx backup "$host" "$db"
        gum style --foreground 40 --bold "  ‚úì Backup complete!"
        sleep 2
        ;;

      "‚¨á  Restore backup")
        echo ""
        local selected
        selected=$(tui_select_backup) || continue
        [[ -z "$selected" ]] && continue

        local target
        target=$(gum input --placeholder "Leave empty for auto-generated name" --header "Target database name:")

        echo ""
        if [[ -n "$target" ]]; then
          gum spin --spinner dot --title "Restoring to $target..." -- dbx restore "$DATA_DIR/$selected" --name "$target"
        else
          gum spin --spinner dot --title "Restoring backup..." -- dbx restore "$DATA_DIR/$selected"
        fi
        gum style --foreground 40 --bold "  ‚úì Restore complete!"
        sleep 2
        ;;

      "‚å®  Query database")
        echo ""
        local host
        host=$(tui_select_host) || continue
        [[ -z "$host" ]] && continue

        local db
        db=$(gum input --placeholder "Leave empty for no database" --header "Database (optional):")

        echo ""
        gum style --foreground 212 --bold "  Opening SQL session... (\\q or Ctrl+D to exit)"
        sleep 1
        if [[ -n "$db" ]]; then
          dbx query "$host" "$db"
        else
          dbx query "$host"
        fi
        ;;

      "üìä Analyze tables")
        echo ""
        local host
        host=$(tui_select_host) || continue
        [[ -z "$host" ]] && continue

        local db
        db=$(gum input --placeholder "Database name" --header "Database:")
        [[ -z "$db" ]] && continue

        dbx analyze "$host" "$db"
        echo ""
        gum input --placeholder "Press Enter to continue..."
        ;;

      "üìã List all backups")
        tui_header
        echo ""
        dbx list
        echo ""
        gum input --placeholder "Press Enter to continue..."
        ;;

      "üßπ Clean old backups")
        echo ""
        local keep
        keep=$(gum input --value "10" --header "Keep how many backups per database?")
        [[ -z "$keep" ]] && keep=10

        if gum confirm "Remove old backups, keeping $keep per database?"; then
          echo ""
          dbx clean --keep "$keep"
          sleep 2
        fi
        ;;

      "üîë Vault & credentials")
        while true; do
          tui_header
          gum style --border rounded --border-foreground 135 --padding "1 2" --width 50 \
            --bold --foreground 135 "VAULT & CREDENTIALS"

          local vault_action
          vault_action=$(gum choose --cursor "‚ñ∏ " \
            "üìã List stored credentials" \
            "‚ûï Set host password" \
            "‚ûñ Delete host password" \
            "üîê Set encryption key" \
            "‚Üê Back")

          case "$vault_action" in
            "üìã List stored credentials")
              echo ""
              dbx vault list
              echo ""
              gum input --placeholder "Press Enter to continue..."
              ;;
            "‚ûï Set host password")
              echo ""
              local host
              host=$(tui_select_host) || continue
              [[ -n "$host" ]] && dbx vault set "$host"
              sleep 1
              ;;
            "‚ûñ Delete host password")
              echo ""
              local host
              host=$(gum input --header "Host name to delete:")
              [[ -n "$host" ]] && dbx vault delete "$host"
              sleep 1
              ;;
            "üîê Set encryption key")
              echo ""
              dbx vault set-encryption-key
              sleep 1
              ;;
            "‚Üê Back"|"")
              break
              ;;
          esac
        done
        ;;

      "‚öô  Configuration")
        while true; do
          tui_header
          gum style --border rounded --border-foreground 208 --padding "1 2" --width 50 \
            --bold --foreground 208 "CONFIGURATION & MANAGEMENT"

          local config_action
          config_action=$(gum choose --cursor "‚ñ∏ " \
            "‚ûï Add host" \
            "‚ûñ Remove host" \
            "üìÅ Add database to host" \
            "üóë  Delete backups" \
            "‚úè  Edit config (advanced)" \
            "üëÅ  Show config" \
            "üÜï Initialize config" \
            "‚Üê Back")

          case "$config_action" in
            "‚ûï Add host")
              echo ""
              local new_host new_type new_user new_hostaddr new_port

              new_host=$(gum input --header "Host alias (e.g., production):" --placeholder "production")
              [[ -z "$new_host" ]] && continue

              new_type=$(gum choose --header "Database type:" "postgres" "mysql")
              [[ -z "$new_type" ]] && continue

              new_user=$(gum input --header "Database user:" --placeholder "postgres")
              [[ -z "$new_user" ]] && continue

              new_hostaddr=$(gum input --header "Host address:" --placeholder "localhost or db.internal")
              [[ -z "$new_hostaddr" ]] && continue

              new_port=$(gum input --header "Port:" --value "$([[ "$new_type" == "postgres" ]] && echo "5432" || echo "3306")")

              # Add to config using jq
              local tmp_config
              tmp_config=$(mktemp)
              jq ".hosts[\"$new_host\"] = {type: \"$new_type\", host: \"$new_hostaddr\", port: $new_port, user: \"$new_user\", databases: {}}" "$CONFIG_FILE" > "$tmp_config" && mv "$tmp_config" "$CONFIG_FILE"

              gum style --foreground 40 --bold "  ‚úì Host '$new_host' added!"

              if gum confirm "Set password for this host now?"; then
                dbx vault set "$new_host"
              fi
              sleep 1
              ;;

            "‚ûñ Remove host")
              echo ""
              local host
              host=$(tui_select_host) || continue
              [[ -z "$host" ]] && continue

              if gum confirm --default=false "Remove host '$host' from config?"; then
                local tmp_config
                tmp_config=$(mktemp)
                jq "del(.hosts[\"$host\"])" "$CONFIG_FILE" > "$tmp_config" && mv "$tmp_config" "$CONFIG_FILE"
                gum style --foreground 40 --bold "  ‚úì Host '$host' removed!"
                sleep 1
              fi
              ;;

            "üìÅ Add database to host")
              echo ""
              local host
              host=$(tui_select_host) || continue
              [[ -z "$host" ]] && continue

              local new_db
              new_db=$(gum input --header "Database name:" --placeholder "myapp")
              [[ -z "$new_db" ]] && continue

              local exclude_tables=""
              if gum confirm "Add tables to exclude from data dump?"; then
                exclude_tables=$(gum input --header "Tables to exclude (comma-separated):" --placeholder "sessions, cache, logs")
              fi

              # Add to config using jq
              local tmp_config
              tmp_config=$(mktemp)
              if [[ -n "$exclude_tables" ]]; then
                local exclude_json
                exclude_json=$(echo "$exclude_tables" | tr ',' '\n' | sed 's/^ *//;s/ *$//' | jq -R . | jq -s .)
                jq ".hosts[\"$host\"].databases[\"$new_db\"] = {exclude_data: $exclude_json}" "$CONFIG_FILE" > "$tmp_config" && mv "$tmp_config" "$CONFIG_FILE"
              else
                jq ".hosts[\"$host\"].databases[\"$new_db\"] = {}" "$CONFIG_FILE" > "$tmp_config" && mv "$tmp_config" "$CONFIG_FILE"
              fi

              gum style --foreground 40 --bold "  ‚úì Database '$new_db' added to '$host'!"
              sleep 1
              ;;

            "üóë  Delete backups")
              echo ""
              if [[ ! -d "$DATA_DIR" ]]; then
                gum style --foreground 196 "No backups found"
                sleep 1
                continue
              fi

              local delete_choice
              delete_choice=$(gum choose --header "Delete backups:" \
                "Select specific backup" \
                "Delete all for a host" \
                "Delete all for a database" \
                "Cancel")

              case "$delete_choice" in
                "Select specific backup")
                  local selected
                  selected=$(tui_select_backup) || continue
                  [[ -z "$selected" ]] && continue

                  if gum confirm --default=false "Delete backup: $selected?"; then
                    rm -f "$DATA_DIR/$selected"
                    rm -f "$DATA_DIR/${selected%.sql.zst*}.meta.json"
                    gum style --foreground 40 --bold "  ‚úì Backup deleted!"
                  fi
                  ;;
                "Delete all for a host")
                  local host
                  host=$(tui_select_host) || continue
                  [[ -z "$host" ]] && continue

                  local count
                  count=$(find "$DATA_DIR/$host" -name "*.sql.zst*" 2>/dev/null | wc -l | tr -d ' ')

                  if gum confirm --default=false "Delete ALL $count backups for '$host'?"; then
                    rm -rf "$DATA_DIR/$host"
                    gum style --foreground 40 --bold "  ‚úì All backups for '$host' deleted!"
                  fi
                  ;;
                "Delete all for a database")
                  local host
                  host=$(tui_select_host) || continue
                  [[ -z "$host" ]] && continue

                  local dbs
                  dbs=$(ls -1 "$DATA_DIR/$host" 2>/dev/null)
                  if [[ -z "$dbs" ]]; then
                    gum style --foreground 196 "No backups for this host"
                    continue
                  fi

                  local db
                  db=$(echo "$dbs" | gum choose --header "Select database:")
                  [[ -z "$db" ]] && continue

                  local count
                  count=$(find "$DATA_DIR/$host/$db" -name "*.sql.zst*" 2>/dev/null | wc -l | tr -d ' ')

                  if gum confirm --default=false "Delete ALL $count backups for '$host/$db'?"; then
                    rm -rf "$DATA_DIR/$host/$db"
                    gum style --foreground 40 --bold "  ‚úì All backups for '$host/$db' deleted!"
                  fi
                  ;;
              esac
              sleep 1
              ;;

            "üëÅ  Show config")
              tui_header
              dbx config show
              echo ""
              gum input --placeholder "Press Enter to continue..."
              ;;
            "‚úè  Edit config (advanced)")
              dbx config edit
              ;;
            "üÜï Initialize config")
              dbx config init
              sleep 2
              ;;
            "‚Üê Back"|"")
              break
              ;;
          esac
        done
        ;;

      "‚ö° Update"*)
        run_self_update
        ;;

      "‚ùå Quit"|"")
        clear
        break
        ;;
    esac
  done
}

cmd_help() {
  cat <<EOF
${BOLD}dbx${NC} - Database backup and restore utility

${BOLD}USAGE:${NC}
  dbx <command> [options]

${BOLD}COMMANDS:${NC}
  tui                          Interactive TUI mode (requires gum)
  backup [-v] <host> <database>  Backup a remote database (-v for verbose)
  restore <source> [--name N]  Restore a backup to local container
  query <host> [database]      Open interactive shell to remote database
  analyze <host> <database>    Interactive table analysis & exclusion picker
  list [host] [database]       List available backups
  clean [--keep N]             Remove old backups (default: keep 10)
  vault set|get|delete|list    Manage host credentials
  vault set-encryption-key     Set backup encryption passphrase
  config init|edit|show        Manage configuration

${BOLD}EXAMPLES:${NC}
  # Setup
  dbx config init              # Create config template
  dbx config edit              # Add your hosts
  dbx vault set production     # Store password securely

  # Enable encryption (optional)
  dbx vault set-encryption-key # Set encryption passphrase
  # Then set "encryption": true in config

  # Backup (auto SSH tunnel if configured)
  dbx backup production myapp
  dbx backup staging myapp

  # Restore to local container
  dbx restore production/myapp/latest
  dbx restore staging/myapp/latest --name myapp_copy

  # Interactive query session
  dbx query production                  # Connect to host
  dbx query production myapp            # Connect to specific database

  # Manage
  dbx list                     # Show all hosts
  dbx list production          # Show databases for host
  dbx clean --keep 5           # Keep only 5 latest per database

${BOLD}CONFIG STRUCTURE:${NC}
  {
    "hosts": {
      "production": {
        "type": "mysql",
        "user": "backup_user",
        "ssh_tunnel": {
          "jump_host": "bastion",        // SSH config host
          "target_host": "db.internal",  // DB from bastion
          "target_port": 3306
        },
        "databases": {
          "myapp": {
            "exclude_data": ["sessions", "cache"]
          }
        }
      }
    }
  }

${BOLD}FEATURES:${NC}
  - SSH tunnels: Auto-creates tunnel for remote DBs, cleans up on exit
  - Encryption: AES-256 encryption at rest (optional, via GPG)
  - DEFINER strip: MySQL views/triggers work locally
  - Exclude tables: Dump schema but skip data for large/sensitive tables
  - Credential storage: macOS Keychain or Linux secret-tool

${BOLD}STORAGE:${NC}
  Backups:  ~/.data/dbx/<host>/<database>/<database>_<timestamp>.sql.zst[.gpg]
  Config:   ~/.config/dbx/config.json
  Secrets:  macOS Keychain or Linux secret-tool (service: dbx)

${BOLD}REQUIREMENTS:${NC}
  - docker (for pg_dump/mysqldump containers)
  - jq, zstd, ssh
  - gpg (optional, for encryption)
EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    backup)
      cmd_backup "$@"
      ;;
    restore)
      cmd_restore "$@"
      ;;
    analyze|stats)
      cmd_analyze "$@"
      ;;
    query|q|shell)
      cmd_query "$@"
      ;;
    list|ls)
      cmd_list "$@"
      ;;
    clean|prune)
      cmd_clean "$@"
      ;;
    vault)
      cmd_vault "$@"
      ;;
    config|cfg)
      cmd_config "$@"
      ;;
    tui|menu)
      cmd_tui
      ;;
    help|--help|-h)
      cmd_help
      ;;
    version|--version|-V)
      echo "dbx $VERSION"
      ;;
    *)
      die "Unknown command: $cmd (run 'dbx help' for usage)"
      ;;
  esac
}

main "$@"
